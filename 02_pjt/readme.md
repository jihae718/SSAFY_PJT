# 두번째 관통 프로젝트

## 소감
어떻게 시작할지 막막하던 문제들도 집중해서 읽고 이해해서 차근차근 단계별로 접근하니 풀리는 경험을 했다. 어떤 문제든 시간만 충분히 주어진다면 풀 수 있겠다는 자신감이 생겼다. <br><br><br>

## 문항별 설명

### a문항
딕셔너리 json파일의 results키의 벨류가 리스트로 이루어져 있는데, 리스트 안에 들어있는 딕셔너리의 개수를 세면 되는 문제였다. api_key는 TMDB사이트에 회원가입해서 개발자 API를 발급받아야한다. <br><br>

### b문항
vote_average값이 8.0이상인 딕셔너리들만 리턴하는 문제였다.<br><br>

### c문항
#### ♥ 람다함수
result = sorted(response['results'], key=lambda x: x['vote_average'], reverse=True) <br><br>
튜플이나 딕셔너리를 정렬하는데, 앞에 있는 놈 말고 뒤에 있는 놈이나 다른 키값으로 정렬하고 싶을때 유용하다. sorted로 모두 묶는 건데 착각해서 좀 헤매다가 구글링해서 문법구조를 보고 적용했다. 내림차순 정렬할때는 reverse=True를 하면 된다.
#### ♥ top5를 구하려면
람다함수로 내림차순 정렬한 리스트에서 [:5] 슬라이싱 이용하면 된다.<br><br>

### d문항
#### ♥ 파라미터
먼저 params를 딕셔너리로 지정해야하는데, 필수값은 반드시 넣고 optional은 안 넣어도 된다. params->URL->response순으로 코딩한다. <br> 
resp = requests.get(URL, params=params).json() <br>
#### ♥ 예외처리
예외처리는 일단 돌려보고 에러가 나는 것을 본다. 에러명이 'IndexError'이니 정상적으로 돌아가는 코드는 try: 에 넣고, 예외처리는 except IndexError: 에 넣으면 된다. <br><br>

### e문항
#### ♥ 딕셔너리 구조 파악
resp1을 출력해보니 너무 길어서 구조를 전체적으로 판단하기 어려웠다. 그래서 resp1의 type을 먼저 검색해보니 dict로 나왔고, 이놈의 구조를 알기 위해서 resp1.keys()를 검색하니 3개밖에 안나왔다. 그래서 필요한 정보를 가지고 있는 키를 알아낸 다음 조건을 부여해서 필요한 정보를 빈 리스트에 추가해서 리스트 두개를 만든 다음, 각각 'cast'키와 'directing'키에 벨류로 추가한다음 dic을 리턴했다. <br>
#### ♥ 예외처리
id검색에 실패할 경우 None을 반환하라해서, 일단 에러가 나타나는 줄과 에러명을 알아냈다. 그런다음 정상적인 부분은 try: 아래에 넣고, 에러는 except IndexError: 로 예외처리했다.